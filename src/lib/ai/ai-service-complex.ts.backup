import { messageAnalyzer } from './message-analyzer'
// Removed business impact analyzer for MVP
import { aiProcessingPipeline } from './processing-pipeline'
import { supabase } from '@/lib/supabase/client'
import { 
  Message, 
  AnalysisResult, 
  ExecutiveSummary, 
  ActionItem, 
  CommunicationInsights,
  DashboardData,
  DecisionContext,
  PriorityLevel
} from '@/types/ai'
import { AIError } from './openai-client'

export class AIService {
  /**
   * Process a new message with full AI analysis
   */
  async processNewMessage(message: Message): Promise<{
    analysis: AnalysisResult
    summary: string
    actionItems: ActionItem[]
    businessImpact: any
    decisionContext?: DecisionContext
  }> {
    try {
      // Simplified AI analysis for MVP
      const [analysis, summary, actionItems] = await Promise.all([
        messageAnalyzer.analyzeMessage(message),
        messageAnalyzer.generateExecutiveSummary(message),
        messageAnalyzer.extractActionItems(message)
      ])

      // Queue for additional processing
      await aiProcessingPipeline.processMessage(message)

      return {
        analysis,
        summary,
        actionItems: actionItems.map(item => ({
          ...item,
          id: `${message.id}-${Date.now()}-${Math.random()}`,
          messageId: message.id,
          status: 'pending' as const,
          businessImpact: this.mapPriorityToBusinessImpact(item.priority),
          createdAt: new Date(),
          updatedAt: new Date(),
          category: (item.category as any) || 'review',
          dueDate: item.dueDate ? new Date(item.dueDate) : undefined
        })),
        businessImpact: { level: 'medium', confidence: 0.7 }, // Simplified placeholder
        decisionContext: undefined
      }
    } catch (error) {
      throw new AIError(
        'Failed to process new message',
        'PROCESS_MESSAGE_ERROR',
        error as Error
      )
    }
  }

  /**
   * Get strategic digest data for dashboard
   */
  async getStrategicDigest(userId: string): Promise<{
    priorityMessages: Array<Message & { analysis: AnalysisResult; summary: string }>
    actionItems: ActionItem[]
    insights: CommunicationInsights
    decisions: DecisionContext[]
    metrics: {
      totalMessages: number
      pendingActions: number
      criticalDecisions: number
      avgResponseTime: number
    }
  }> {
    try {
      // Get priority messages with analysis
      const { data: priorityData } = await supabase
        .from('messages')
        .select(`
          *,
          message_analysis(*),
          executive_summaries(summary)
        `)
        .eq('user_id', userId)
        .in('message_analysis.priority', ['critical', 'high'])
        .order('created_at', { ascending: false })
        .limit(10)

      // Get pending action items
      const { data: actionItems } = await supabase
        .from('action_items')
        .select('*')
        .eq('user_id', userId)
        .eq('status', 'pending')
        .order('priority', { ascending: false })
        .order('due_date', { ascending: true })
        .limit(20)

      // Get latest insights
      const { data: insightsData } = await supabase
        .from('communication_insights')
        .select('*')
        .eq('user_id', userId)
        .order('generated_at', { ascending: false })
        .limit(1)

      // Get pending decisions
      const { data: decisions } = await supabase
        .from('decision_contexts')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(5)

      // Calculate metrics
      const { data: metricsData } = await supabase
        .from('communication_insights')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(1)

      const priorityMessages = priorityData?.map(msg => ({
        id: msg.id,
        sender: msg.sender_email,
        channel: msg.source,
        timestamp: new Date(msg.message_date),
        content: msg.content,
        subject: msg.subject || '',
        priority: this.mapScoreToPriority(msg.priority_score),
        isVIP: msg.is_vip,
        analysis: null as any,
        summary: msg.ai_summary || ''
      })) || []

      const insights = insightsData?.[0] || this.getDefaultInsights()
      const metrics = metricsData?.[0] || this.getDefaultMetrics()

      return {
        priorityMessages,
        actionItems: actionItems || [],
        insights,
        decisions: decisions || [],
        metrics
      }
    } catch (error) {
      throw new AIError(
        'Failed to get strategic digest',
        'DIGEST_ERROR',
        error as Error
      )
    }
  }

  /**
   * Generate real-time insights for dashboard
   */
  async generateRealTimeInsights(userId: string): Promise<CommunicationInsights> {
    try {
      // Get recent messages for analysis
      const { data: recentMessages } = await supabase
        .from('messages')
        .select('*')
        .eq('user_id', userId)
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
        .order('created_at', { ascending: false })
        .limit(50)

      if (!recentMessages || recentMessages.length === 0) {
        return this.getDefaultInsights()
      }

      // Generate insights using AI
      const insights = await messageAnalyzer.generateInsights(recentMessages)

      // Save insights to database
      await supabase.from('communication_insights').insert({
        user_id: userId,
        patterns: insights.patterns,
        recommendations: insights.recommendations,
        trends: insights.trends,
        delegation_opportunities: insights.delegationOpportunities,
        generated_at: new Date().toISOString()
      })

      return {
        patterns: insights.patterns || [],
        recommendations: insights.recommendations || [],
        trends: insights.trends || [],
        delegationOpportunities: insights.delegationOpportunities || [],
        efficiencyMetrics: await this.calculateEfficiencyMetrics(userId),
        generatedAt: new Date()
      }
    } catch (error) {
      throw new AIError(
        'Failed to generate real-time insights',
        'INSIGHTS_ERROR',
        error as Error
      )
    }
  }

  /**
   * Analyze message sentiment and extract key topics
   */
  async analyzeMessageSentiment(message: Message): Promise<{
    sentiment: 'positive' | 'neutral' | 'negative' | 'urgent'
    confidence: number
    topics: string[]
    urgencyLevel: 'immediate' | 'today' | 'thisWeek' | 'normal'
    emotionalTone: string[]
  }> {
    try {
      const analysis = await messageAnalyzer.analyzeMessage(message)
      
      return {
        sentiment: analysis.sentiment,
        confidence: analysis.confidence,
        topics: analysis.topics,
        urgencyLevel: analysis.urgency,
        emotionalTone: this.extractEmotionalTone(message.content)
      }
    } catch (error) {
      throw new AIError(
        'Failed to analyze message sentiment',
        'SENTIMENT_ERROR',
        error as Error
      )
    }
  }

  /**
   * Get AI-powered recommendations for message handling
   */
  async getMessageRecommendations(message: Message): Promise<{
    actions: Array<{
      type: 'respond' | 'delegate' | 'schedule' | 'escalate' | 'archive'
      priority: PriorityLevel
      description: string
      reasoning: string
      timeframe?: string
    }>
    suggestedResponses: string[]
    delegationCandidates: string[]
    schedulingSuggestions: string[]
  }> {
    try {
      const analysis = await messageAnalyzer.analyzeMessage(message)
      
      // Generate contextual recommendations based on analysis
      const actions = this.generateActionRecommendations(analysis, message)
      const suggestedResponses = await this.generateResponseSuggestions(message)
      
      return {
        actions,
        suggestedResponses,
        delegationCandidates: this.identifyDelegationCandidates(message),
        schedulingSuggestions: this.generateSchedulingSuggestions(analysis)
      }
    } catch (error) {
      throw new AIError(
        'Failed to get message recommendations',
        'RECOMMENDATIONS_ERROR',
        error as Error
      )
    }
  }

  /**
   * Calculate communication efficiency metrics
   */
  async calculateEfficiencyMetrics(userId: string): Promise<{
    averageResponseTime: number
    messageVolume: number
    priorityDistribution: Record<PriorityLevel, number>
    channelDistribution: Record<string, number>
    actionItemCompletion: number
    delegationRate: number
    decisionSpeed: number
  }> {
    try {
      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)

      // Get message volume and channel distribution
      const { data: messages } = await supabase
        .from('messages')
        .select('channel, created_at, message_analysis(priority)')
        .eq('user_id', userId)
        .gte('created_at', thirtyDaysAgo.toISOString())

      // Get action item completion rates
      const { data: actionItems } = await supabase
        .from('action_items')
        .select('status, completed_at, created_at')
        .eq('user_id', userId)
        .gte('created_at', thirtyDaysAgo.toISOString())

      // Calculate metrics
      const messageVolume = messages?.length || 0
      const channelDistribution = this.calculateChannelDistribution(messages || [])
      const priorityDistribution = this.calculatePriorityDistribution(messages || [])
      const actionItemCompletion = this.calculateCompletionRate(actionItems || [])

      return {
        averageResponseTime: 720, // 12 hours default - would calculate from actual response data
        messageVolume,
        priorityDistribution,
        channelDistribution,
        actionItemCompletion,
        delegationRate: 0.15, // 15% - would calculate from delegation data
        decisionSpeed: 48 // 48 hours average - would calculate from decision data
      }
    } catch (error) {
      throw new AIError(
        'Failed to calculate efficiency metrics',
        'METRICS_ERROR',
        error as Error
      )
    }
  }

  /**
   * Private helper methods
   */
  private mapPriorityToBusinessImpact(priority: PriorityLevel): 'very-high' | 'high' | 'medium' | 'low' {
    switch (priority) {
      case 'critical': return 'very-high'
      case 'high': return 'high'
      case 'medium': return 'medium'
      case 'low': return 'low'
      default: return 'medium'
    }
  }

  private mapScoreToPriority(score: number): PriorityLevel {
    if (score >= 90) return 'critical'
    if (score >= 70) return 'high'
    if (score >= 40) return 'medium'
    return 'low'
  }

  private getDefaultInsights(): CommunicationInsights {
    return {
      patterns: [],
      recommendations: [],
      trends: [],
      delegationOpportunities: [],
      efficiencyMetrics: {
        averageResponseTime: 720,
        messageVolume: 0,
        priorityDistribution: { critical: 0, high: 0, medium: 0, low: 0 },
        channelDistribution: {},
        actionItemCompletion: 0,
        delegationRate: 0,
        decisionSpeed: 48
      },
      generatedAt: new Date()
    }
  }

  private getDefaultMetrics() {
    return {
      totalMessages: 0,
      pendingActions: 0,
      criticalDecisions: 0,
      avgResponseTime: 720
    }
  }

  private extractEmotionalTone(content: string): string[] {
    // Simple keyword-based emotional tone detection
    const tones = []
    const lowerContent = content.toLowerCase()
    
    if (lowerContent.includes('urgent') || lowerContent.includes('asap') || lowerContent.includes('immediately')) {
      tones.push('urgent')
    }
    if (lowerContent.includes('concern') || lowerContent.includes('worried') || lowerContent.includes('issue')) {
      tones.push('concerned')
    }
    if (lowerContent.includes('excellent') || lowerContent.includes('great') || lowerContent.includes('success')) {
      tones.push('positive')
    }
    
    return tones
  }

  private generateActionRecommendations(analysis: AnalysisResult, message: Message) {
    const actions = []
    
    if (analysis.actionRequired) {
      actions.push({
        type: 'respond' as const,
        priority: analysis.priority,
        description: 'Requires immediate response',
        reasoning: 'Message contains action items requiring executive decision',
        timeframe: analysis.timeToDecision ? `${analysis.timeToDecision} hours` : 'Today'
      })
    }
    
    if (analysis.priority === 'medium' || analysis.priority === 'low') {
      actions.push({
        type: 'delegate' as const,
        priority: 'medium' as const,
        description: 'Consider delegation to appropriate team member',
        reasoning: 'Lower priority item that could be handled by others'
      })
    }
    
    return actions
  }

  private async generateResponseSuggestions(message: Message): Promise<string[]> {
    // Generate AI-powered response suggestions
    return [
      'Thank you for bringing this to my attention. I will review and provide direction by [timeframe].',
      'Please schedule a brief meeting to discuss this further.',
      'I approve this proposal. Please proceed with implementation.'
    ]
  }

  private identifyDelegationCandidates(message: Message): string[] {
    // Identify potential delegation candidates based on message content and sender
    return ['Direct Report', 'Department Head', 'Subject Matter Expert']
  }

  private generateSchedulingSuggestions(analysis: AnalysisResult): string[] {
    const suggestions = []
    
    if (analysis.decisionRequired) {
      suggestions.push('Schedule decision review meeting')
    }
    
    if (analysis.stakeholderLevel === 'executive' || analysis.stakeholderLevel === 'board') {
      suggestions.push('Add to next leadership team meeting')
    }
    
    return suggestions
  }

  private calculateChannelDistribution(messages: any[]): Record<string, number> {
    return messages.reduce((acc, msg) => {
      acc[msg.channel] = (acc[msg.channel] || 0) + 1
      return acc
    }, {})
  }

  private calculatePriorityDistribution(messages: any[]): Record<PriorityLevel, number> {
    return messages.reduce((acc, msg) => {
      const priority = msg.message_analysis?.[0]?.priority || 'medium'
      acc[priority as PriorityLevel] = (acc[priority as PriorityLevel] || 0) + 1
      return acc
    }, { critical: 0, high: 0, medium: 0, low: 0 })
  }

  private calculateCompletionRate(actionItems: any[]): number {
    if (actionItems.length === 0) return 0
    const completed = actionItems.filter(item => item.status === 'completed').length
    return (completed / actionItems.length) * 100
  }
}

// Singleton instance
export const aiService = new AIService()